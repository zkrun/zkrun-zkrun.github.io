<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>linux标准io | 故乡的雪花飘落了</title>

  
  <meta name="author" content="昆汀">
  

  
  <meta name="description" content="某人曾留下来的东西">
  

  
  
  <meta name="keywords" content="linux">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="linux标准io"/>

  <meta property="og:site_name" content="故乡的雪花飘落了"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="故乡的雪花飘落了" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <script>
    (function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
    })();
    </script>
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">故乡的雪花飘落了</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/categories">Categories</a></li>
      
        <li><a href="/tags">Tags</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>linux标准io</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/01/31/linux标准io/" rel="bookmark">
        <time class="entry-date published" datetime="2023-01-31T13:45:08.000Z">
          2023-01-31
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>标准io是另一套io接口，但底层还是依赖于文件io，优点就是自带缓冲区以及效率更快，而且标准io是跨平台的，文件io操作只能在linux进行。</p>
<span id="more"></span>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a><strong>数据流</strong></h3><p>先说一下流的概念，其实就是连续数据的集合。<br>一般流可以分为 文本流 与 二进制流</p>
<h3 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a><strong>文件指针</strong></h3><p>在一个文件打开时，会在内存中开辟一块区域作为对文件信息的描述，这个描述保存在一个结构体类型的变量中，该结构体类型是由系统定义的，取名为FILE。  </p>
<hr>
<p>在标准io中，提前预定义了三个流指针，在应用程序运行自动被打开.<br>分别是:<br><strong>stdin</strong>对应的是标准输入设备<br><strong>stdout</strong>对应的是标准输出设备<br><strong>stderr</strong>对应的是标准错误输出设备<br>上面对应的文件描述符分别为0,1,2。  </p>
<hr>
<p>我们常用的printf函数其实是默认为stdout为流对象。如果我们想改变的话需要用到<strong>fprintf</strong>函数:  </p>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, …)</span>;</span><br></pre></td></tr></table></figure>

<p>比如我想在屏幕上输出一个hello linux。那我只需要:</p>
<p><code> fprintf(stdout,&quot;hello linux&quot;);</code>  </p>
<p>上面这句话如果在单语句执行的时候是没有什么问题的，但是假如我在fprintf下面加上一个死循环，比如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;hello linux&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>那么就输出不了这句话，这就涉及到缓存了：  </p>
<hr>
<p>上面说过标准io自带缓存区，分为三类:<br><strong>1.全缓存:等缓存区的数据占满以后再进行系统调用</strong><br><strong>2.行缓存:等缓存区的数据占满一行后进入io操作(stdout就是行缓存)</strong><br><strong>3.不缓存:来什么数据我就进行io操作(stderr就是不缓存，以免错误堆积)</strong><br>所以上面的数据默认fprintf的数据没有占满一行，程序也没有结束，不输出，如果要输出的话有三种办法:<br>1.后面加一个 <strong>\n</strong><br>2.用fflush强制刷新缓存<br>3.把流对象换成stderr    </p>
<hr>
<p>一般情况下,程序在结束时会 自动刷新缓冲区,但是当程序还未结束时,刷新缓冲区则需要调用 fflush() 函数 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/嵌入式学习/">嵌入式学习</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/linux/">linux</a>
    </span>
    

    </div>

    
  </div>
</article>

  
	<section id="comment" class="comment">
		<div id="gitalk-container"></div>
	</section>
	<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
	<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
	<script>
		var gitalk = new Gitalk({
			clientID: 'bb93b87a14125e3cc588',
			clientSecret: 'cfd397d929190cc616347ba9037d7667f8e2a0f0',
			repo: 'blog_comments',
			owner: 'zkrun',
			admin: ['zkrun'],
			id: location.pathname,
			distractionFreeMode: false
		})
		gitalk.render('gitalk-container')
	</script>










    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2023 昆汀
    
  </p>
</footer>
    
    
<script>
    var _hmt = _hmt || [];
    ( function () {
        var hm = document.createElement( "script" );
        hm.src = "https://hm.baidu.com/hm.js?zkrun";
        var s = document.getElementsByTagName( "script" )[ 0 ];
        s.parentNode.insertBefore( hm, s );
    } )();
</script>

  </div>
</div>
</body>
</html>